---
layout: post
title: Setting up a Python Virtual Environment
tags:
  - python
  - venv
  - virtualenv
  - virtual environment
  - pip
typora-root-url: ..
---

You should setup a Python virtual environment to ensure that your library dependencies are consistent and segregated from your global packages. This can help to prevent potential versioning conflicts and makes it easier to package your app for use by others (or you, but on a different machine).

Previously, you had to install dedicated packages to create and manage Python virtual environments - such  as `pipenv` or `virtualenv`. Python does however now come with it's own solution `venv` which accomplishes much of the same and can be run directly as a Python module without any installation steps.

## Create a Virtual Environment

As the `venv` module comes preinstalled, you can create a new virtual environment by running:

`python -m venv virtenv`

This will create a new directory called `virtenv` in your current directory (you can call it whatever you want - general naming scheme is `venv`) which will include it's own Python interpreter, `pip` installation and any packages you subsequently install once the environment is activated.

If you look inside the new directory, you will find it has it's own `Lib/site-packages` structure (where any new packages will be installed), alongside it's own Python / pip executables. The version of Python within your new virtual environment will be the same as the one you used to run the `venv` command above.

## Activate the Environment

To 'activate' the virtual environment, you need to call the `activate` shell script which got created by the previous command. This sets a bunch of environment variables to point the `python` / `pip` commands to your newly created `venv` instead of the globally installed version - in effect creating a completely separate Python installation.

If on Windows - `virtenv\Scripts\activate.bat`

If on Linux/Mac - `virtenv/Scripts/activate`

You should notice that your shell prompt got changed to include the name of the `venv` at the start. If you  now run the `where` / `which` commands to show the location of the executables, it should show those located in the `virtenv` directory.

`where python` ==> `\virtenv\Scripts\python.exe` 

`where pip` ==> `\virtenv\Scripts\pip.exe`

## Install Packages

Running the `pip list` command shows that we don't currently have anything installed (even if you had installed something globally).

```
pip (19.1.1)
setuptools (28.8.0)
```

You can use the `pip` command now to install packages as you would normally e.g.

`pip install requests`

If we check the list of installed packages again, you can see that `requests` has been added. Note that this could be a different version to the one installed in the global `site-packages`.

```
certifi (2019.3.9)
chardet (3.0.4)
idna (2.8)
pip (19.1.1)
requests (2.22.0)
setuptools (28.8.0)
urllib3 (1.25.3)
```

If you check the `virtenv\Lib\site-packages` directory, you should find that`requests` has been installed there.

## Generate requirements.txt

You can run the `pip freeze` command to generate a `requirements` file containing all the currently installed packages - helpful if you want to recreate the exact same environment on a different machine.

`pip freeze > requirement.txt`

The contents of which will be something like:

```
certifi==2019.3.9
chardet==3.0.4
idna==2.8
requests==2.22.0
urllib3==1.25.3
```

## Installing Packages from requirements.txt

When on a new machine with another blank virtual environment, you can use the `requirements.txt` file generated by `pip freeze` to install all the packages required for your project at once:

`pip install -r requirements.txt`

`Pip` will run through each entry in the file and install the exact version number specified. This makes it easy to create consistent virtual environments - in which you know the exact version of every package installed without the hassle of installing each one manually.

## Deactivate the Environment

To deactivate the virtual environment and return all the environment variables to their previous values (pointing instead to your global Python installation), simply run:

`deactivate`

The virtual environment name should be removed from your shell prompt to denote that no environment is currently active.